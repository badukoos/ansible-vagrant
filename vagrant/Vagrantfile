# -*- mode: ruby -*-
require 'yaml'
require 'shellwords'

ROOT = File.expand_path(File.dirname(__FILE__))
INV_PATH = File.join(ROOT, 'inventory.yml')
LINUX_PLAYBOOK = File.join(ROOT, 'linux.yml')
WIN_PLAYBOOK = File.join(ROOT, 'windows.yml')

def usage
  puts <<~HELP

    All standard vagrant commands work as usual.

    This Vagrantfile is primarily inventory driven. Hosts, groups etc
    come from inventory.yml

    Usage:
      VAGRANT_GROUP=<group|group/subgroup|host1,host2> vagrant up [args]

    Ansible:
      ANSIBLE_EXTRA_ARGS="--tags foo -vvv" vagrant up <host>

    Use the --help flag to display the default vagrant help
  HELP
end

if ARGV.include?('--custom-help')
  usage
  abort
end

def env_str(key, default = nil)
  v = ENV[key]
  return default if v.nil? || v.strip.empty?
  v
end

def load_inventory(path)
  raise "Missing inventory #{path}" unless File.exist?(path)
  YAML.load_file(path)
end

def merge_hash(a, b)
  a = a.is_a?(Hash) ? a : {}
  b = b.is_a?(Hash) ? b : {}
  out = a.dup
  b.each do |k, v|
    if out[k].is_a?(Hash) && v.is_a?(Hash)
      out[k] = merge_hash(out[k], v)
    else
      out[k] = v
    end
  end
  out
end

def flatten_hosts(inv)
  hosts = {}

  walker = lambda do |node, groups, acc_vars|
    return unless node.is_a?(Hash)

    cur_vars = acc_vars.dup
    cur_vars.merge!(node['vars'] || {})

    if node['hosts'].is_a?(Hash)
      node['hosts'].each do |hn, hv|
      hosts[hn] ||= { 'vars' => {}, 'groups' => [] }

      merged = cur_vars.merge(hv || {})
      merged['provider_options'] = merge_hash(cur_vars['provider_options'], (hv || {})['provider_options'])

      hosts[hn]['vars'].merge!(merged)
      hosts[hn]['groups'] |= groups

      end
    end

    if node['children'].is_a?(Hash)
      node['children'].each do |g, sub|
        walker.call(sub, groups + [g], cur_vars)
      end
    end
  end

  root = inv['all'].is_a?(Hash) ? inv['all'] : inv
  walker.call(root, [], {})
  hosts
end

def in_group?(meta, group)
  (meta['groups'] || []).map(&:downcase).include?(group.to_s.downcase)
end

PROVIDER_OPTIONS_ALLOWED = %w[
  cpus
  memory_mb
  cpu_mode
  nic_model
  kvm_hidden
  memory_backing
  sync_folders
].freeze

def apply_provider_options(lv, host, opts)
  return unless opts.is_a?(Hash)

  unknown = opts.keys.map(&:to_s) - PROVIDER_OPTIONS_ALLOWED
  raise "Host #{host}: unsupported provider_options keys: #{unknown.sort.join(', ')}" unless unknown.empty?

  begin
    lv.cpus = Integer(opts['cpus']) if opts.key?('cpus')
    lv.memory = Integer(opts['memory_mb']) if opts.key?('memory_mb')
    lv.cpu_mode = opts['cpu_mode'].to_s if opts['cpu_mode']
    lv.nic_model_type = opts['nic_model'].to_s if opts['nic_model']
    lv.kvm_hidden = !!opts['kvm_hidden'] if opts.key?('kvm_hidden')

    case (opts['memory_backing'] || 'off').to_s.downcase
    when '', 'off'
    when 'shared'
      lv.memorybacking :access, mode: 'shared'
    when 'memfd'
      lv.memorybacking :access, mode: 'shared'
      lv.memorybacking :source, type: 'memfd'
    else
      raise "Host #{host}: provider_options.memory_backing must be off/memfd/shared"
    end
  rescue ArgumentError, TypeError => e
    raise "#{e.class}: Host #{host}: #{e.message}, opts=#{opts.inspect}"
  end
end

def apply_sync_folders(vm, host, opts)
  return unless opts.is_a?(Hash)

  items = opts['sync_folders']
  return unless items.is_a?(Array)

  items.each_with_index do |s, i|
    next unless s.is_a?(Hash) && s['enabled']

    type = (s['type'] || 'disabled').to_s.downcase
    next if type == 'disabled'
    raise "Host #{host}: sync_folders[].type must be virtiofs/nfs/disabled, got: #{type}" unless %w[virtiofs nfs].include?(type)

    src = s['host_path'].to_s.strip
    dst = s['guest_path'].to_s.strip
    raise "Host #{host}: sync_folders[].host_path required" if src.empty?
    raise "Host #{host}: sync_folders[].guest_path required" if dst.empty?

    args = {
      id: "sync-#{host}-#{i}",
      type: type
    }

    args[:readonly] = true if !!s['readonly']

    vm.vm.synced_folder src, dst, **args
  end
end

inv = load_inventory(INV_PATH)
HOSTS = flatten_hosts(inv)
raise "No hosts found in inventory" if HOSTS.empty?

group_env = env_str('VAGRANT_GROUP')
selectors = (group_env || '').split(/[,\s]+/).reject(&:empty?)

def matches_selector?(name, meta, sel)
  groups = (meta['groups'] || []).map(&:downcase)
  s = sel.downcase
  return true if s == name.downcase

  if s.include?('/') || s.include?('+')
    tokens = s.split(/[\/+]/).reject(&:empty?)
    (tokens - groups).empty?
  else
    groups.include?(s)
  end
end

TARGETS =
  if selectors.empty?
    HOSTS
  else
    HOSTS.select { |n, m| selectors.any? { |s| matches_selector?(n, m, s) } }
  end

abort "No matching hosts for VAGRANT_GROUP=#{group_env}" if TARGETS.empty?

Vagrant.configure('2') do |config|

  # implict mapping disabled on purpose
  config.vm.synced_folder '.', '/vagrant', disabled: true, id: 'vagrant-root'

  TARGETS.each do |name, meta|
    v = meta['vars'] || {}

    ip = v['ansible_host']
    os = v['os'].to_s.downcase
    box = v['vagrant_box']

    raise "Host #{name}: ansible_host required" if ip.to_s.empty?
    raise "Host #{name}: os required" if os.empty?
    raise "Host #{name}: vagrant_box required"  if box.to_s.empty?

    config.vm.define name do |vm|
      vm.vm.box = box
      vm.vm.hostname = name

      if os == 'windows'
        vm.vm.communicator = 'winrm'
        vm.winrm.username = v['ansible_user']
        vm.winrm.password = v['ansible_password']
      else
        vm.vm.communicator = 'ssh'
        vm.ssh.username = v['ansible_user']
      end

      vm.vm.network :private_network, ip: ip
      vm.vm.provider :libvirt do |lv|
        apply_provider_options(lv, name, v['provider_options'])
      end

      apply_sync_folders(vm, name, v['provider_options'])

      playbook =
        v['ansible_playbook'] ||
        (os == 'windows' ? WIN_PLAYBOOK : LINUX_PLAYBOOK)

      vm.vm.provision 'ansible' do |ans|
        ans.playbook = playbook
        ans.inventory_path = INV_PATH
        ans.limit = name

        extra = env_str('ANSIBLE_EXTRA_ARGS')
        ans.verbose = :v unless extra&.match?(/(^|\s)-v{1,5}\b/)
        ans.raw_arguments = Shellwords.split(extra) if extra
      end

      if in_group?(meta, 'controller')
        vm.trigger.after :destroy do |t|
          t.info = 'Cleaning controller markers'
          t.run  = { inline: "rm -f \"#{ROOT}/.vagrant/markers/dc_ready\" || true" }
        end
      end
    end
  end
end